#include "I2C.h"
#include "string.h"

static LPC_I2C_TypeDef** I2C_Controller_table={
		(LPC_I2C_TypeDef*)	LPC_I2C0,
		(LPC_I2C_TypeDef*)	LPC_I2C1,
		(LPC_I2C_TypeDef*)	LPC_I2C2
};


void I2C_config(uint32_t controller, uint32_t freq){
	LPC_I2C_TypeDef* I2C= I2C_Get_Controller(controller);
	// I2CONSET/I2CONCLR
	//bit 6 I2EN interface enable
	I2C->I2CONSET=0x40; //master mode

	//PINSEL1: P0.27 SDA0, P0.28 SCL0 -Function 01
	LPC_PINCON->PINSEL1 |= 0x18000000;

	//enable CLK on PCONP register
	uint32_t PCONP_masks[3]= {0x80,0x8000,0x4000000};
	LPC_SC->PCONP|= PCONP_masks[controller];

	//Clock settings
	//EEPROM 100KHz
	//SCLK= 100 MHz, PCLK= SCLK/4=25 MHz; 2500/100=250;
	//define I2SCLH
	I2C->I2SCLH=125;
	//define I2SCLL
	I2C->I2SCLL=125;

}

void I2C_Start(LPC_I2C_TypeDef* I2C){
	// I2CONSET/I2CONCLR
	//bit 5 STA START flag
	I2C->I2CONSET=0x20;

}

void I2C_Stop(LPC_I2C_TypeDef* I2C){
	// I2CONSET/I2CONCLR
	//bit 4 STO STOP flag
	I2C->I2CONSET=0x10;
}


void I2C_Write(LPC_I2C_TypeDef* I2C, uint8_t addr, void *data, uint32_t size){
	uint8_t* curr=data;
	I2C_Start(I2C);

	//TODO

}


void* I2C_Transfer(LPC_I2C_TypeDef* I2C, uint32_t addr,void *data, uint32_t size, uint8_t direction){
	//direction = 0 Write , direction = 1 Read
	unsigned char status;
	void *inicialAddr = data;
	void *finalAddr = ((char*)data + size * sizeof(char));
	I2C_Start(I2C);
	while(1){
		if((I2C->I2CONSET & I2C_SI_FLAG) == I2C_SI_FLAG){
			switch(LPC2106_I2C.I2STAT){
				case START:
				case RSTART:
					setSlaveAddr(addr, read);
					LPC2106_I2C.I2CONCLR = I2C_STA_FLAG;
				case I2C_STATE_SLAVE_ADDRESS_READ_ACK:
					LPC2106_I2C.I2CONSET = I2C_AA_FLAG;
					LPC2106_I2C.I2CONCLR = I2C_SI_FLAG;
					break;
				case I2C_STATE_DATA_RECEIVED_ACK:
					I2C_Read(data);
					data = ((char *)data) + sizeof(char);
					if(data == finalAddress){ //last byte.
						status = I2C.I2STAT;
						LPC2106_I2C.I2CONCLR = I2C_AA_FLAG | I2C_SI_FLAG;
						LPC2106_I2C.I2CONCLR = I2C_SI_FLAG;
						I2C_Stop();
						return status;
					}
					LPC2106_I2C.I2CONSET = I2C_AA_FLAG;
					LPC2106_I2C.I2CONCLR = I2C_SI_FLAG;
					break;
				case I2C_STATE_DATA_RECEIVED_NACK:
					I2C_Read(data);
					status = LPC2106_I2C.I2STAT;
					I2C_Stop(I2C);
					return status;
				case I2C_STATE_SLAVE_ADDRESS_WRITE_ACK:
					I2C_Write(data);
					data = ((char *)data) + sizeof(char);
					break;
				case I2C_STATE_SLAVE_DATA_ACK:
					if(data == finalAddress){ //last byte.
						status = LPC2106_I2C.I2STAT;
						I2C_Stop(I2C);
						return status;
					}
					I2C_Write(data);
					data = ((char *)data) + sizeof(char);
					break;
				case I2C_STATE_TRANSMITION_LOST:
					LPC2106_I2C.I2CONSET = (I2C_STA_FLAG );
					LPC2106_I2C.I2CONCLR = I2C_SI_FLAG;
					break;
				default:
					case I2C_STATE_BUS_ERROR:
					status = LPC2106_I2C.I2STAT;
					I2C_Stop(I2C);
					return status;
			}
		}
	}
}

void I2C_Write_Byte(LPC_I2C_TypeDef* I2C,void* data){
	memcpy(data, (void*)&I2C->I2DAT, sizeof(char));
}

void I2C_Read_Byte(LPC_I2C_TypeDef* I2C, void* data){
	memcpy((void*)&I2C->I2DAT, data, sizeof(char));
}

static LPC_I2C_TypeDef* I2C_Get_Controller(uint8_t controller){
	return (LPC_I2C_TypeDef*) I2C_Controller_table+controller;
}
